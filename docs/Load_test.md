# 부하 테스트 및 가상 장애 대응 문서

## 부하 테스트
### 부하 테스트 대상 및 이유
선착순 쿠폰 발급 요청 API

**이유**
- 선착순 쿠폰 발급 요청은 동시에 다수의 사용자가 접근하는 고부하 트랜잭션으로 시스템의 부하 처리 능력이 중요한 기능임
- 특히, 제한된 수량의 쿠폰을 놓고 경쟁이 발생하는 만큼 동시성 제어, 트랜잭션 처리 속도, 데이터 정합성 유지가 필수적임
- 따라서, 부하 테스트를 통해 시스템이 높은 트래픽에서도 안정적으로 동작하는지 검증할 필요가 있음

### 부하 테스트 목적
- 선착순 쿠폰 발급 요청 API가 대량의 동시 요청 상황에서 안정적으로 동작하는지 평가하고 경쟁 조건에서의 응답 시간, 처리량, 동시성 제어 등을 검증
- 이를 통해 쿠폰 재고 관리의 일관성 유지, 데이터 무결성 보장, 과부하 시 성능 저하 및 장애 발생 가능성 탐색 등을 목표로 한다
- 또한 예상되는 트래픽을 효율적으로 처리할 수 있도록 병목 지점을 사전에 파악하고 최적화하는 것이 핵심 목적이다

#### 자세한 목표 설정

- **성능 한계 확인**
  - 선착순 쿠폰 발급 API가 처리할 수 있는 최대 동시 요청 수 및 처리 가능한 TPS 파악
- **안정성 평가**
  - 과부하 상황에서도 API가 정상적으로 동작하는지 점검하고 트래픽 증가 시 데이터 정합성을 유지할 수 있는지 검증
- **경쟁 환경에서의 성능 검증**
  - 여러 사용자가 동시에 쿠폰을 요청할 때, 중복 발급이나 데이터 충돌 없이 정확하게 동작하는지 확인

### 부하 테스트 시나리오
부하 테스트는 다양한 트래픽 패턴을 통해 선착순 쿠폰 발급 API의 성능과 동시성 제어 능력을 평가하는 것이 목표이다.

- **정상 트래픽 시나리오**:
  - 평소 예상되는 수준의 트래픽에서 API가 정상적으로 작동하는지 확인
  - 예시: 1초에 1~5건의 쿠폰 발급 요청
- **피크 트래픽 시나리오**:
  - 한정된 수량의 쿠폰이 빠르게 소진되는 이벤트 상황을 시뮬레이션
  - 예시: 1초에 1000건 이상의 동시 쿠폰 요청 발생
- **부하 및 스트레스 테스트 시나리오**:
  - 시스템의 한계를 테스트하기 위해 요청량을 점진적으로 증가시키면서 API의 반응을 분석
  - 예시: 동시 요청 수를 10명 → 100명 → 1000명까지 증가시키며 시스템의 응답 속도 및 오류 발생 여부 확인
  - 임계값을 초과했을 때 트랜잭션이 실패하거나 API가 응답하지 않는지 여부를 분석

위 시나리오를 통해 API가 대량의 동시 요청을 안정적으로 처리할 수 있는지와 비정상적인 트래픽 패턴에서 발생할 수 있는 병목 현상을 파악하는 것이 목표이다.



### 부하 테스트 스크립트
본 부하 테스트에서는 k6를 사용한다.

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

const BASE_URL = 'http://localhost:8080/api/v1/coupons/issue';
const DURATION = '5m'; // 테스트 실행 시간
const RAMP_UP_TIME = '1m'; // 부하 증가 시간
const RAMP_DOWN_TIME = '30s'; // 부하 감소 시간

// 요청 바디 생성 함수 (랜덤 사용자 ID와 쿠폰 코드)
function generatePayload() {
  return JSON.stringify({
    userId: Math.floor(Math.random() * 100000), // 임의의 사용자 ID
    couponCode: 'COUPON2025' // 테스트용 쿠폰 코드
  });
}

// 부하 테스트 설정
export const options = {
  scenarios: {
    // 정상 트래픽 시나리오 (1초에 5건 요청)
    // - 평소 예상되는 수준의 트래픽을 시뮬레이션
    // - API가 정상적인 부하에서도 안정적으로 응답하는지 확인
    normal_load: {
      executor: 'constant-arrival-rate',
      rate: 5, // 초당 5건 요청
      timeUnit: '1s',
      duration: DURATION, // 전체 테스트 시간 (5분)
      preAllocatedVUs: 10, // 미리 할당된 가상 사용자 수
    },

    // 피크 트래픽 시나리오 (1초에 1000건 이상 요청)
    // - 한정된 수량의 쿠폰이 빠르게 소진되는 이벤트 상황을 시뮬레이션
    // - 대량의 요청이 짧은 시간 내에 집중적으로 들어올 때 API가 정상적으로 처리하는지 확인
    peak_load: {
      executor: 'ramping-arrival-rate',
      startRate: 10, // 초당 10건 요청으로 시작
      timeUnit: '1s',
      preAllocatedVUs: 50, // 미리 할당된 가상 사용자 수
      stages: [
        { target: 1000, duration: RAMP_UP_TIME }, // 1분 동안 초당 1000건으로 증가
        { target: 1000, duration: '2m' }, // 2분 동안 유지
        { target: 10, duration: RAMP_DOWN_TIME } // 30초 동안 감소
      ],
    },

    // 부하 및 스트레스 테스트 시나리오
    // - 시스템의 한계를 테스트하기 위해 점진적으로 부하를 증가시키면서 API의 반응을 분석
    // - 동시 요청 수를 10명 → 100명 → 500명 → 1000명까지 증가시키며 API의 응답 속도 및 오류 발생 여부 확인
    // - 임계값을 초과했을 때 트랜잭션이 실패하거나 API가 응답하지 않는지 여부를 분석
    stress_test: {
      executor: 'ramping-arrival-rate',
      startRate: 10, // 초기 요청 속도 (초당 10건)
      timeUnit: '1s',
      preAllocatedVUs: 50, // 미리 할당된 가상 사용자 수
      stages: [
        { target: 10, duration: '30s' },  // 초당 10건 요청 (30초 동안)
        { target: 100, duration: '1m' }, // 초당 100건 요청 (1분 동안)
        { target: 500, duration: '1m' }, // 초당 500건 요청 (1분 동안)
        { target: 1000, duration: '1m' }, // 초당 1000건 요청 (1분 동안)
        { target: 10, duration: '30s' }  // 요청량을 줄여 정상적인 시스템 회복 확인
      ],
    }
  }
};

// API 요청 함수 (선착순 쿠폰 발급 요청)
export default function () {
  const headers = { 'Content-Type': 'application/json' };
  const res = http.post(BASE_URL, generatePayload(), { headers });

  check(res, {
    'is status 200': (r) => r.status === 200, // 정상 응답 확인
  });

  sleep(1); // 1초 대기 후 다음 요청 실행
}

```

### 부하 테스트 시나리오 별 성능 지표
#### k6 부하테스트 지표
K6 부하 테스트에서 수집되는 주요 성능 지표와 이를 활용한 **병목 탐색 방법**을 정리

---

1. **요청 및 응답 관련 지표**

| 지표명                | 설명                                                                         | 병목 탐색 방법 |
|----------------------|-----------------------------------------------------------------------------|----------------|
| **`http_req_duration`** | 한 HTTP 요청의 전체 지속 시간 (`connecting + waiting + receiving`)       | 응답 시간이 길다면 **DB 쿼리 성능 문제**, **네트워크 지연**, **서버 리소스 부족** 등을 확인해야 함 |
| **`http_req_waiting`** | 서버가 요청을 처리하는 데 걸린 시간                                         | 백엔드 처리 속도를 점검하고 **서버 부하 분산, 캐싱 적용** 등을 고려해야 함 |
| **`http_req_receiving`** | 응답 데이터를 클라이언트가 수신하는 데 걸린 시간                         | 클라이언트의 네트워크 환경을 점검하고 **데이터 압축, 패킷 최적화** 등을 검토 |
| **`http_req_sending`** | 요청 데이터를 서버로 전송하는 데 걸린 시간                                 | 요청 데이터 크기를 최소화하고 **API 요청을 최적화**해야 함 |

---

2. **네트워크 및 연결 관련 지표**

| 지표명                | 설명                                                                          | 병목 탐색 방법 |
|----------------------|------------------------------------------------------------------------------|----------------|
| **`http_req_blocked`** | 네트워크에서 요청이 차단된 시간 (DNS 조회, 연결 대기 포함)                   | 네트워크 설정 및 **DNS 응답 속도 최적화** 필요 |
| **`http_req_connecting`** | 서버와의 연결 설정 시간                                                  | 서버와 클라이언트 간 **네트워크 상태 점검 및 개선** |

---

3. **서버 부하 및 성능 지표**

| 지표명                | 설명                                                                         | 병목 탐색 방법 |
|----------------------|-----------------------------------------------------------------------------|----------------|
| **`vus`** | 실행 중인 가상 사용자(Virtual Users) 수 | **동시 요청 처리량 증가 시 서버 성능 저하 여부 확인** |
| **`http_reqs`** | 초당 처리된 HTTP 요청 수 (Throughput) | 예상된 TPS 대비 처리량이 낮다면 **서버 리소스 및 애플리케이션 최적화 필요** |
| **`iteration_duration`** | 각 테스트 반복(iteration)이 완료되는데 걸리는 시간 | 처리 속도가 예상보다 느려진다면 **애플리케이션 최적화 필요** |

---

4. **실패율 및 오류 탐색 지표**

| 지표명                | 설명                                                                         | 병목 탐색 방법 |
|----------------------|-----------------------------------------------------------------------------|----------------|
| **`http_req_failed`** | 실패한 HTTP 요청 비율                                                      | 서버 응답 오류가 많다면 **API 로그 분석 후 원인 파악** |
| **`error_rate`** | 요청 대비 발생한 에러 비율 | 높은 에러율은 **시스템 과부하, 코드 오류, 네트워크 장애** 가능성 |
| **`data_received`** | 서버가 클라이언트로부터 받은 데이터 양 | 요청 크기를 최적화하고 **불필요한 데이터 전송 방지** |
| **`data_sent`** | 클라이언트가 서버로 전송한 데이터 양 | 응답 크기가 크다면 **데이터 압축 및 최적화 적용** |

---

#### 병목 현상 탐색 및 해결 방법

1. **HTTP 요청 실패율 증가 (`http_req_failed`)**
- **문제 원인:** 서버가 과부하 상태이거나, 코드 오류 또는 네트워크 장애 발생
- **해결 방법:**
  - API 응답 로그 분석 (`/actuator/loggers`)
  - 서버 리소스(CPU, 메모리) 확인 및 스케일링 고려
  - 네트워크 상태 점검 및 트래픽 제한 적용

2. **응답 시간 지연 (`http_req_duration` 증가)**
- **문제 원인:** 백엔드의 처리 속도가 느리거나, DB 쿼리 최적화 필요
- **해결 방법:**
  - Slow Query 로그 분석 (`EXPLAIN ANALYZE`)
  - Redis 캐싱 활용하여 DB 부하 감소
  - 비동기 처리 적용 (Kafka 등)

3. **동시 요청 증가 시 서버 성능 저하 (`vus` 증가 시 처리량 감소)**
- **문제 원인:** 동시 요청이 많을 때 서버의 리소스 한계 도달
- **해결 방법:**
  - 로드 밸런서 적용 (Nginx, HAProxy)
  - 서버 스케일링 (오토스케일링 적용)
  - 애플리케이션 내부에서 비효율적인 동기 처리 개선

4. **초당 처리 요청 수(Throughput) 감소 (`http_reqs` 낮음)**
- **문제 원인:** 서버가 요청을 감당하지 못하고 큐잉이 발생
- **해결 방법:**
  - DB Connection Pool 크기 증가
  - 서버의 동시 요청 처리 방식 개선 (Reactive Programming 적용)
  - 비효율적인 로직 최적화 (불필요한 API 호출 제거)

5. **네트워크 문제 (`http_req_blocked`, `http_req_connecting` 증가)**
- **문제 원인:** 네트워크 응답 지연, DNS 문제, 서버 과부하
- **해결 방법:**
  - 서버 네트워크 환경 점검 및 CDN 적용
  - API Gateway 최적화 (캐시 적용, 압축 설정)
  - DNS 설정 최적화 (TTL 값 조정)

---
##### k6 부하 테스트 결과

![k6_log](/docs/img/k6-load-test.png)

##### **1. 정상 트래픽 시나리오 (Normal Load)**
> **설정:** 초당 5건의 요청을 5분 동안 지속 (`rate: 5`, `duration: 5m`)  
> **목표:** 일반적인 트래픽에서 API가 정상적으로 동작하는지 평가

##### **성능 지표**
| 지표 | 값 | 해석 |
|------|------|------|
| **총 요청 수 (http_reqs)** | 22,012 | 5분 동안 초당 5건의 요청이 안정적으로 처리됨 |
| **평균 응답 시간 (http_req_duration avg)** | 4.81ms | API가 빠르게 응답 |
| **최대 응답 시간 (http_req_duration max)** | 58.61ms | 일부 요청에서 지연 발생 |
| **90백분위 응답 시간 (p90 http_req_duration)** | 8.05ms | 대부분의 요청이 8ms 이내 응답 |
| **95백분위 응답 시간 (p95 http_req_duration)** | 9.53ms | 95% 이상의 요청이 9.53ms 이내 응답 |
| **실패율 (http_req_failed)** | 0.00% | 모든 요청이 정상적으로 처리됨 |

**결론:**
- 일반적인 부하에서는 API가 빠르고 안정적으로 응답
- 일부 요청에서 응답 시간이 길어질 수 있으나 전체적으로 정상 작동

---

##### **2. 피크 트래픽 시나리오 (Peak Load)**
> **설정:** 초당 10건에서 시작해 1분 동안 초당 1000건으로 증가, 2분 유지 후 점진적 감소  
> **목표:** 급격한 트래픽이 몰릴 때 API가 정상적으로 처리할 수 있는지 확인

##### **성능 지표**
| 지표 | 값 | 해석 |
|------|------|------|
| **최대 동시 가상 사용자 수 (vus_max)** | 110 | 최대 110명까지 동시 요청 처리 가능 |
| **평균 응답 시간 (http_req_duration avg)** | 4.81ms | 트래픽 증가에도 성능 유지 |
| **최대 응답 시간 (http_req_duration max)** | 58.61ms | 트래픽 증가 시 응답 지연 발생 가능 |
| **90백분위 응답 시간 (p90 http_req_duration)** | 8.05ms | 높은 부하에서도 응답 시간 안정적 |
| **Dropped Iterations** | 226,688 | 요청이 너무 많아 일부 요청이 처리되지 못함 |

##### **주의할 점:**
- `Dropped Iterations`(226,688)이 발생 → **서버가 초당 1000건 이상의 요청을 감당하지 못하고 일부 요청이 손실됨**
- **대규모 이벤트(선착순 쿠폰 발급 등)에서 요청 손실 가능성 존재**
- 서버 확장 및 로드 밸런싱 적용 필요

##### **결론:**
- 일정 수준의 높은 트래픽까지는 안정적이지만, **1000TPS를 초과하는 트래픽에서는 요청 손실 발생**
- 대규모 이벤트 대응을 위해 **수평 확장(Auto Scaling), 캐싱, 비동기 큐 적용 필요**

---

##### **3. 부하 및 스트레스 테스트 시나리오 (Stress Test)**
> **설정:** 동시 요청 수를 점진적으로 증가 (`10 → 100 → 500 → 1000`), 4분 동안 유지 후 감소  
> **목표:** 서버의 성능 한계를 찾고, 임계치를 넘으면 장애가 발생하는지 확인

##### **성능 지표**
| 지표 | 값 | 해석 |
|------|------|------|
| **최대 동시 가상 사용자 수 (vus_max)** | 110 | 최대 110명까지 동시 요청 처리 가능 |
| **평균 응답 시간 (http_req_duration avg)** | 4.81ms | 트래픽 증가에도 성능 유지 |
| **최대 응답 시간 (http_req_duration max)** | 58.61ms | 부하가 증가할수록 응답 지연 발생 가능 |
| **95백분위 응답 시간 (p95 http_req_duration)** | 9.53ms | 95%의 요청이 9.53ms 이내 응답 |
| **Dropped Iterations** | 226,688 | 서버가 감당할 수 없는 요청이 발생하여 일부 요청이 무시됨 |

##### **주의할 점:**
- `Dropped Iterations`(226,688)이 발생하여 **1000명 이상의 동시 사용자가 몰릴 경우 서버가 과부하될 가능성 있음**
- 부하가 증가할수록 `Insufficient VUs` 경고 발생 → **현재 설정된 가상 사용자 수(VUs)로 감당하기 어려운 트래픽**
- **서버의 최대 부하 한계를 측정하고, 최대 TPS를 고려하여 인프라 확장 필요**

#### **결론:**
- API는 일정 부하까지는 안정적이지만, **1000TPS를 초과하면 일부 요청이 버려지고 병목이 발생함**
- 대규모 트래픽을 대비한 **부하 분산, 캐싱, 비동기 처리 등의 최적화 필요**

---



# 가상 장애 대응 문서
## 테스트 결과 기반 장애 대응 전략

### 1. 장애 개요
- **장애 발생 위치:** `쿠폰 발급 API (/api/v1/coupons/issue)`
- **장애 유형:** 과부하로 인한 요청 누락 & 서버 리소스 초과
- **발생 원인:**
  - **피크 트래픽 (Peak Load)**: 초당 1000건 이상의 요청 발생 시 일부 요청 누락 (`Dropped Iterations: 226,688`)
  - **부하 증가 (Stress Test)**: 동시 요청 증가 시 응답 지연 (`http_req_duration p95: 9.53ms`)
  - **리소스 부족**: `Insufficient VUs`(가상 사용자 부족) 경고 발생 → **서버 확장 필요**
  - **DB 부하 과다**: Redis 처리 속도보다 쿠폰 발급 요청 속도가 더 빠르게 증가하여 병목 발생

---

### 2. 장애 감지 및 대응 절차
#### **1단계: 장애 감지 (Monitoring & Alert)**
| 감지 방법 | 대응 방안 |
|----------|----------|
| **Prometheus** - 메트릭 기반 모니터링 (`http_req_failed`, `http_req_duration`) | 응답 실패율(`http_req_failed`)이 5% 초과 시 **경고(Alert) 전송** |
| **Grafana Dashboard** - 실시간 지표 확인 (`vus_max`, `dropped_iterations`) | 최대 동시 요청 수(`vus_max`) 증가 시 **알람 설정** |
| **Log 분석 (ELK 스택 / CloudWatch)** | 로그에서 **쿠폰 발급 실패 및 DB 오류 증가 감지** |
| **APM (New Relic, Datadog)** | API 응답 지연 (`p95 http_req_waiting`) 발생 시 Slack 알림 전송 |

---

#### **2단계: 장애 대응 및 조치**
| 대응 조치 | 상세 내용 |
|----------|----------|
|  **Auto Scaling 활성화** | - 동적 트래픽 증가에 대응하기 위해 서버 Auto Scaling 설정 (AWS ASG, Kubernetes HPA 적용) |
|  **Redis 캐싱 최적화** | - 쿠폰 발급 성공 여부를 Redis에 캐싱하여 DB 부하 감소 (TTL 적용) |
|  **큐잉 시스템 도입** | - Kafka, RabbitMQ 기반 **비동기 처리 방식으로 전환**하여 병목 제거 |
|  **로드 밸런싱 최적화** | - Nginx / AWS ALB / Kubernetes Ingress 적용하여 트래픽을 여러 서버에 분산 |
|  **Rate Limiting 적용** | - **사용자별 초당 최대 요청 제한** (ex. 10초당 3회)으로 서버 부하 예방 |
|  **DB 인덱스 최적화** | - `coupon_code` 컬럼에 인덱스 추가하여 쿠폰 조회 속도 향상 |

---

### 3. 장애 복구 프로세스
| 단계 | 조치 내용 |
|------|---------|
| **장애 감지** | Prometheus, Grafana, APM을 통해 장애 발생 감지 | 
| **즉각 대응** | 1) Auto Scaling 수동 확장<br>2) 쿠폰 발급 서비스 일시 중지 후 복구 |
| **원인 분석** | 1) 로그 분석 (`failed request`, `Dropped Iterations`)<br>2) DB Slow Query 검사 |
| **근본 해결** | 1) 비동기 처리 도입 (Kafka)<br>2) Rate Limiting 설정 | 
| **사후 보고** | 장애 발생 원인, 대응 방법, 재발 방지 대책 정리하여 공유 | 

---

### 4. 재발 방지 대책
#### **숏텀 (1~2개월 이내)**
- **리소스 확장 및 최적화**
  - 서버 자동 스케일링 활성화하여 트래픽 급증에 빠르게 대응
  - Redis 캐싱 적용하여 동일 쿠폰 요청의 중복 처리 방지
  - DB 인덱스 최적화 및 쿼리 성능 개선
- **단기 부하 테스트 진행**
  - 예상 최대 트래픽을 기준으로 K6 부하 테스트 강화
  - 비정상적인 트래픽 패턴(봇 트래픽, 동시성 충돌) 시뮬레이션 테스트 진행

#### **미드텀 (3~6개월 이내)**
- **성능 최적화**
  - API 응답 최적화를 위한 트랜잭션 범위 축소 & DB 부하 분산 적용
  - 로드 밸런서 최적화를 통해 트래픽 분산 효율 개선
- **부하 분산 전략 개선**
  - 피크 트래픽 패턴 분석을 통해 트래픽 분산 전략 수립
  - 필요 시 지역별 서버 확장 적용

#### **롱텀 (6개월 이상)**
- **고가용성 아키텍처 구축**
  - 멀티 리전 & 멀티 존 배포를 통한 장애 대비 시스템 구축
  - 장애 발생 시 자동 Failover 및 빠른 복구 지원
- **전사적 장애 대응 매뉴얼 및 교육 강화**
  - 장애 대응 매뉴얼 주기적 검토 & 대응 훈련 강화

---

### 5. 장애 후 분석
- **장애 발생 원인**
  - 예상보다 높은 트래픽 급증으로 인해 **서버 & Redis 부하 초과**
  - **동기 처리 방식의 한계로 병목 발생** → **비동기 메시지 큐 필요성 대두**
  - **Rate Limiting 미적용** → 대량 요청을 제어하지 못함

- **재발 방지 조치**
  - 비동기 처리 적용 (Kafka, RabbitMQ)
  - API Rate Limiting 설정 (10초 3회 요청 제한)
  - 부하 테스트 시나리오 개선 (최대 1500TPS 테스트 추가)


