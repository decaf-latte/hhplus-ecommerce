# MSA 환경에서 도메인별 배포 시 트랜잭션 처리의 한계와 해결 방안

---
## 개요
서비스 규모 확장에 따라 MSA 환경에서 도메인별로 배포 단위를 분리해야 할 경우, 이에 따른 트랜잭션 처리의 한계와 해결 방안을 다루는 서비스 설계 문서

---
## 서비스 내 주요기능 
- 현재 서비스는 모놀리식 아키텍처로 구성되어 있으며 주요 기능은 다음과 같다

- **주문결제**
  ```
  주문결제_TX() {
    장바구니_검증_및_조회 ();
    총 주문 금액 계산();
    사용자_조회();
    상품 재고 조회();
    주문 생성();
    쿠폰 할인 적용();
    결제 처리();
    주문 상태 변경 (결제 성공);
    상품 재고 감소();
  
    try {
      데이터_플랫폼_전송();
    } catch (Exception e) {
      log.error("데이터 플랫폼 전송 실패: {}", e.getMessage());
    }
  }
  ```
  - 장바구니, 주문, 결제, 쿠폰, 상품, 회원 등의 서비스가 하나의 트랜잭션으로 묶여 처리됨 
  - 데드락이나 트랜잭션 타임아웃 발생 가능성 증가 
  - 데이터 플랫폼 전송이 실패할 경우, 트랜잭션과 무관한 작업임에도 불구하고 불필요한 예외 처리 로직이 포함됨
  
- 이 중 데이터 플랫폼 전송은 아래와 같이 Spring Event 를 사용하여 데이터 플랫폼 전송을 비동기로 처리할 수 있다
    ```
    주문결제_TX() {
      장바구니_검증_및_조회 ();
      총 주문 금액 계산();
      사용자_조회();
      상품 재고 조회();
      주문 생성();
      쿠폰 할인 적용();
      결제 처리();
      주문 상태 변경 (결제 성공);
      상품 재고 감소();
  }

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(PaidOrderEvent paidOrderEvent) {
        try {
            dataplatformService.sendData(paidOrderEvent.getOrderId());
        } catch (Exception e) {
            log.error("DataPlatform 전송 실패 : {}", e.getMessage());
        }
    }
    ```
    - `@Async` 어노테이션을 사용하여 비동기로 처리
      - 메인 트랜잭션과 분리하여 독립적으로 실행
      - 데이터 플랫폼 전송 실패 시에도 주문 트랜잭션에는 영향을 주지 않음
    - `@TransactionalEventListener` 를 사용하여 트랜잭션 이벤트 발생 시점을 지정
      - 주문 결제 트랜잭션이 성공적으로 커밋된 후 이벤트 실행
      - 주문이 롤백되면 데이터 플랫폼 전송도 수행되지 않음
    - 관심사 분리
      - 데이터 플랫폼 전송 로직을 별도의 이벤트 핸들러로 이동하여 코드 결합도를 낮춤
      - 주문 결제 로직과 데이터 전송 로직이 분리되어 유지보수성이 향상
    - 응답 속도 개선
      - 메인 트랜잭션에서 데이터 플랫폼 전송 로직을 제거하여 사용자 응답 시간이 단축
    - 확장 가능성 증가
      - 이벤트 기반 구조로 변경하여 새로운 기능을 추가할 때 기존 코드를 수정할 필요 없음
      - 향후 메시지 브로커(Kafka, RabbitMQ 등)를 추가하여 MSA 환경에서도 확장 가능


---
## 서비스 분리 설계 및 트랜잭션 처리 방안
### MSA 환경 내 서비스 분리

1. `주문 서비스` : 주문 생성, 조회
2. `결제 서비스` : 결제 조회, 결제 이력 생성
3. `장바구니 서비스` : 장바구니 검증, 조회
4. `상품 서비스` : 상품 조회, 상품 재고 차감, 상품 재고 조회
5. `회원 서비스` : 사용자 조회 , 사용자 잔액 충전/차감, 사용자 잔액 조회
6. `쿠폰 서비스` : 쿠폰 조회, 쿠폰 사용

### **주문결제** 서비스 분리
```java
장바구니_검증_TX() {
    장바구니_검증();
    장바구니_조회();
}

주문_생성_TX() {
    주문_생성();
    주문_상태_변경(대기중);
}

결제_처리_TX() {
    결제_정보_조회();
    결제_이력_생성();
}

사용자_잔액_차감_TX() {
    사용자_잔액_조회();
    사용자_잔액_차감();
}

재고_확인_TX() {
    상품_재고_조회();
}

재고_차감_TX() {
    상품_재고_차감();
}

쿠폰_검증_TX() {
    쿠폰_적용_가능_여부_확인();
}

쿠폰_적용_TX() {
    쿠폰_사용();
    쿠폰_할인_적용();
}

주문_완료_TX() {
    주문_상태_변경(결제완료);
}

데이터_플랫폼_전송_TX() {
    주문_데이터_전송();
}

이벤트_처리_TX() {
    주문_완료_이벤트_발행();
}

```

### MSA 환경(분산 환경)에서의 트랜잭션 처리 한계
- MSA 환경에서는 각 서비스가 독립적으로 트랜잭션을 관리하므로 모놀리식 환경에서 제공하는 ACID(Atomicity, Consistency, Isolation, Durability) 트랜잭션을 보장하기 어렵다
1. 분산 트랜잭션 관리가 어려움
   - 여러 데이터베이스를 사용하므로 동기적으로 트랜잭션을 처리하면 성능 저하 및 데이터 불일치 발생 가능성 증가
2. 즉각적인 데이터 정합성 보장이 어려움
   - MSA에서는 서비스 간 비동기 메시지 처리로 인해 일관성이 지연될 가능성이 있음 (예: 주문이 생성되었지만, 결제 시스템이 응답하지 않는 경우)
3. 데드락 및 타임아웃 위험 증가
   - 서비스 간 네트워크 호출이 증가하면서 동기 호출이 많아질 경우 타임아웃 발생 가능성 증가
   - 여러 서비스가 같은 데이터(예: 사용자 잔액, 상품 재고)를 동시에 수정하려고 하면 데드락 발생 가능성이 높아짐
4. 복잡한 장애 복구 및 롤백 처리
   - 일부 서비스에서 트랜잭션이 완료되고, 다른 서비스에서 실패하면 데이터 불일치가 발생
5. 서비스 간 강한 결합도 증가 위험
   - MSA에서는 각 서비스가 독립적이어야 하지만, 트랜잭션을 위해 동기 호출이 많아지면 강한 결합도가 형성됨
   - 서비스 간 호출이 많을수록 네트워크 비용과 장애 가능성 증가

- 이러한 한계점을 해결하기 위한 방안으로는 대표적으로 `2PC (Two-Phase Commit) 패턴`과 `SAGA 패턴` 이 있다


---

## 해결방안

### 1. 2PC (Two-Phase Commit) 패턴
- 분산 환경에서도 ACID 트랜잭션을 보장하기 위한 프로토콜
- **트랜잭션 매니저** 가 모든 서비스에 트랜잭션을 요청하고 최종적으로 커밋 또는 롤백 결정함

![2pc](/docs/img/2pc.png)

#### Prepare 단계
- 모든 서비스가 트랜잭션 수행 준비 완료(Prepare 상태) 보고
- 트랜잭션 매니저가 확인 후 커밋 여부 결정

#### Commit 단계
- 모든 서비스가 준비 완료 상태이면 최종 커밋 수행
- 하나라도 실패하면 롤백 수행

#### 예시
1. 사용자가 주문 요청을 보내면 Transaction Coodinator가 트랜잭션을 시작한다.
2. Coodinator가 Order Microservice에게 주문 정보 저장에 대한 Prepare 요청을 보낸다.
3. Coodinator가 Product Microservice에게 재고 차감에 대한 Prepare 요청을 보낸다.
4. Coodinator가 두 서비스에 대해 트랜잭션 처리 준비가 완료되었음을 확인하면 Commit 요청을 보낸다.


#### 결론
- 2PC 방안은 트랜잭션의 원자성을 보장하는 방식으로, 모든 서비스는 성공하거나 실패한다
- 2PC 방안은 분산 트랜잭션 처리를 위한 전통적인 방법이지만 트랜잭션 매니저에 의존하여 모든 서비스에 대해 준비 상태를 확인하고 상태 변경하는 방법이라 성능 측면에서 효율적인 방법은 아니다
- NoSQL 등 일부 구현에도 지원하지 않아서 제약이 있는 방안이다


### 2. SAGA 패턴
- MSA 환경에서 가장 많이 사용되는 분산 트랜잭션 관리 패턴 
- 각 서비스가 독립적인 로컬 트랜잭션을 수행하고 다음 서비스로 트랜잭션을 전달 
- 트랜잭션이 실패하면 보상트랜잭션을 실행하여 롤백을 수행

#### Choreography (오케스트레이션 없이 이벤트 기반)
![Choreography](/docs/img/saga-코레오그래피.png)
- 각 서비스가 이벤트를 통해 트랜잭션을 연결하며 중앙 조정자 없이 서비스 간의 직접적인 이벤트 트리거 방식


#### 예시

1. 주문 요청하면 Order 서비스는 주문 저장 트랜잭션을 처리하고 결과를 Product 서비스에게 이벤트로 전달한다
2. 트랜잭션 성공, 실패 응답이 큐 (channel)에 들어간다
3. Product 서비스의 이벤트 핸들러가 발생한 주문 요청에 대해 재고 차감 시도한다
4. 재고 차감 시도한 후 결과에 대해 이벤트를 발생시킨다
5. Order 서비스는 결과에 따라 실패한 경우에는 보상 트랜잭션, 문제 없는 경우에는 다음 프로세스를 진행한다 

#### 장점
- 중앙 오케스트레이터 없이 독립적인 서비스 운영 가능
- 확장성이 뛰어남
#### 단점
- 서비스 간 의존성이 증가하여 트랜잭션 흐름이 복잡해질 수 있음
- 디버깅 및 장애 분석이 어려움


#### Orchestration (중앙 조정자 방식)
![Orchestration](/docs/img/saga-오케스트레이션.png)

- 중앙에서 오케스트레이터가 트랜잭션의 순서를 관리

#### 예시
1. 주문 요청하면 Order 서비스에서 요청을 수신하고, 중계자가 주문 로직인 주문 저장 동작을 수행한다 
2. 재고 차감 명령 이벤트를 발생시킨다 
3. Product 서비스가 재고 차감을 시도한다 
4. 재고 차감을 시도한 결과를 이벤트로 응답한다 
5. 주문 로직 트랜잭션이 끝나면 중계자를 종료하여 전체 트랜잭션 처리를 종료한다

#### 장점
- 트랜잭션 흐름이 명확하여 디버깅이 용이하고 장애 발생 시 보상 트랜잭션을 효과적으로 수행가능하다
#### 단점
- 중앙 오케스트레이터가 병목될 가능성이 있고 추가적인 인프라 비용이 발생할 수 있다





